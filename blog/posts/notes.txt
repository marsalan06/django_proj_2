1) created project blog by django-admin startproject blog
2) created app by pyhton manage.py startapp posts
3) before creating superuser python manage.py migrate 
4) then create super user by python manage.py createsuperuser
5) register the app in settings.py of blog
    'posts.apps.PostsConfig' is used 
    https://stackoverflow.com/questions/41933615/proper-way-to-register-apps-in-django
6) time zone in settings.py will be Asia/Karachi

Creating Models in Posts
1) from django.db.models import fields
2) create models.Model class with fields to define the data we need from the user
3) create PostsForms with meta class to create the form and get data 

creating html template
1) this time each app will have its own template folder
2) created layout.html and index.html with {{form}} jinja

create view in views.py 
1) import Posts and PostsForms from models 
2) create a route with object of PostsForms and render the index.html template

create urls.py in posts 
1) import the posts.views, create the urlpattern list in it 
2) in the urls.py of blog import include and add path 
    Errors that accur are of pylance import so inplace of posts.models use .models 
    and names of Post and PostForms create multiple import error so use Post_Form instead 
    https://stackoverflow.com/questions/50424524/django-cannot-import-name-model


3) create the route register in blog urls.py 

Views.py file of posts 
1) create validation use form.save() instance

Make migrations and migrate before using the form because no table exists 

2) in views.py file to get the data use the Post.object.all() method to get all the data and pass it as an 
arrgument in the render function 
4) in the html code after form run the for loop on rows to show data 


For MYSQl usage:
1) \sql
2)\connect root@localhost:3306
3)create database blog_db;
{{
    4)create table posts (title varchar(50) not null, content varchar(300), datestamp DATE ,timestamp time);
Dont do this first check tables in blog_db after makemigrations}} 


5) edit in settings.py in database
6) python manage.py makemigrations 
    this creates a model based table its self , appname_models

having an error of MySQL Error 2003 (HY000): Can't connect to MySQL server on 'localhost' (10061)
    go to run ==> service.msc ==> search MySQL ==> run service ==> go to shell again and check  


DJANGO MODEL FORM validations
Feild Error validation:
in models.py --> from django.core import validators --> for validation
we can use the validators on either the model or form, but in form we didnt describe any feild type so we
use it on models, in title we will now use a list of validators. we need an error msg to show why the data
wasnt excepted , so in index.py we will place errors 
using the jinija code for error checking, 
            {% if form.title.errors %}
                {% for err_title in form.title.errors %}
                    <p>{{err_title|escape}}</p>
                {{% endfor %}}
            {{% endif %}}

custom validators also are used, we create a function and raise a custom error using 
validators.ValidationError("custom msg"), and pass it in the validators list 


Non Feild Error validation:
non feild errors are raised by the forms, we create a def clean(self) method to check as dictionary 
key value pairs for passed parameters, the error raised are through the clean method, 

we override the clean method and use the fields list to genarate key value pairs
we use a single jinga code line, 


Django comes with an admin pannel, settings of this pannel are provided in admin.py 
it has django.contrib import admin, import the model of app (posts), register it in admin.py using 
admin.site.register(POSTS)

but before login, migrate first, create a superuser to login ,when we login we see all objects of models ,
in models place a def __str__ method, this allows the superuser to edit the posts, 
but for the django admin panel the form validation wont work so place validation on the model itself,

We now also create a new model named category with a title feild, 
python manage.py make makemigrations, run it , apply migrations by python manage.py migrate, run mysql show tables,
shows posts_category, we add category through admin panel that doesnt depend on views.py and check in mysql
select * all from posts_category, to see this data , we just add category.objects.all() to get the data and pass
it in return statement.  

using built in autherization and authentication,in settings.py --> INSTALLED_APPS List we have 3 items relating
to authentication and autherization, .contrib.auth, .contrib.contenttypes, .contrib.sessions , auth is related 
username and password , contenttypes is for allowed contents, authentication doesnt mean complete autherization
only superuser can have complete autherization, in admin panel of the django we can create users and group of users
to have multiple rights, to have our own front end we'll have our own app 

using python manage.py shell command in cli,shell me run from posts.models import Posts , posts=Posts.objects.all()
to get all posts, posts.objects.get(id=1) to get a particular post with all fields

from django.contrib.auth import authenticate
user=authenticate(username="arsalan",password="06061997")
user.is_authenticated --> true

from django.contrib.auth.models import User
users= User.objects.all()
users ==> returns arsalan in a query set 
users.username, users.first_name , users.last_name, users.email, users.password # will be hashed 

After user app we now create relationship api's
Realtionship apis in models: create relations between models , django project website pe model relationship api 
usage, 
1) What is a relationship, normalization of a data base is creating multiple tables linked together to avoid 
data redundancy and maintain flexiblity, django mvc's relationship api is the most easy and effective as compared
to other mvc frameworks,
    a) many to many
    b) many to one
    c) one to one relationship 
first we'll use one to one relationship
2) in posts app's model.py , we'll create a one to one relationship between posts model and user
3) in models.py of post we import django.contrib.auth.models.User 
4) we move the category model above the post model
5) in the posts model class we add a User entry with the field to be models.OnetoOneField(User,on_delete=models.CASCADE)
    marked as (A), One to one field acts a forign key but is unique
6) to fill it in the front end place user in the fields in the PostsForms, (B), for category we didnt create a 
    front end form, we used the admin panel 
7) model.CASCADE means you cant delete a user without removing its related fields in this case posts
8)we deleted the blog_db database and created it and again, makemigrations and migrate,
9)create superuser, python manage.py createsuperuser --username= --email=
10) runserver
11) go to user/register to make couple of users, 
12) now in the root path we will have the user drop down with users in it
13) issues that arised
    a) one to one relationship me we cant post more than once for one user and i fucking tried it for 1 hour


